<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust语法速查 on 手册</title><link>https://www.panwenbin.com/cookbook/rust-syntax/</link><description>Recent content in Rust语法速查 on 手册</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 11 Apr 2024 00:00:00 +0800</lastBuildDate><atom:link href="https://www.panwenbin.com/cookbook/rust-syntax/index.xml" rel="self" type="application/rss+xml"/><item><title>字符串</title><link>https://www.panwenbin.com/cookbook/rust-syntax/string/</link><pubDate>Thu, 11 Apr 2024 00:00:00 +0800</pubDate><guid>https://www.panwenbin.com/cookbook/rust-syntax/string/</guid><description> 字符串 # 遍历Unicode字符 # for c in &amp;#34;中国人&amp;#34;.chars() { println!(&amp;#34;{}&amp;#34;, c); }</description></item><item><title>基础</title><link>https://www.panwenbin.com/cookbook/rust-syntax/basic/</link><pubDate>Sat, 06 Apr 2024 00:00:00 +0800</pubDate><guid>https://www.panwenbin.com/cookbook/rust-syntax/basic/</guid><description>基础 # mut # 默认变量是不可变的(immutable)
fn main() { let x = 5; println!(&amp;#34;The value of x is: {}&amp;#34;, x); x = 6; // error[E0384]: cannot assign twice to immutable variable `x` println!(&amp;#34;The value of x is: {}&amp;#34;, x); } 加上mut
fn main() { let mut x = 5; println!(&amp;#34;The value of x is: {}&amp;#34;, x); x = 6; println!(&amp;#34;The value of x is: {}&amp;#34;, x); } const # const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; shadowing # fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!</description></item><item><title>控制流</title><link>https://www.panwenbin.com/cookbook/rust-syntax/control-flow/</link><pubDate>Sat, 06 Apr 2024 00:00:00 +0800</pubDate><guid>https://www.panwenbin.com/cookbook/rust-syntax/control-flow/</guid><description>控制流 # if条件 # if .. else .. # fn main() { let number = 3; if number &amp;lt; 5 { println!(&amp;#34;condition was true&amp;#34;); } else { println!(&amp;#34;condition was false&amp;#34;); } } else if # fn main() { let number = 6; if number % 4 == 0 { println!(&amp;#34;number is divisible by 4&amp;#34;); } else if number % 3 == 0 { println!(&amp;#34;number is divisible by 3&amp;#34;); } else if number % 2 == 0 { println!</description></item><item><title>简写</title><link>https://www.panwenbin.com/cookbook/rust-syntax/shorten/</link><pubDate>Sat, 06 Apr 2024 00:00:00 +0800</pubDate><guid>https://www.panwenbin.com/cookbook/rust-syntax/shorten/</guid><description>简写 # unwrap # 对于Result&amp;lt;T, E&amp;gt;类型，我们需要频繁使用Match来获取其中的值，当我们在写主逻辑时可以先不考虑错误处理，此时使用unwrap()方法可以快速获取其中的值，如果有错误则会panic。
use std::fs::File; fn main() { let f = File::open(&amp;#34;hello.txt&amp;#34;); let f = match f { Ok(file) =&amp;gt; file, Err(error) =&amp;gt; { panic!(&amp;#34;Problem opening the file: {:?}&amp;#34;, error) }, }; } 如果用unwrap
use std::fs::File; fn main() { let f = File::open(&amp;#34;hello.txt&amp;#34;).unwrap(); } 如果要自定义panic信息，可以使用expect()方法
use std::fs::File; fn main() { let f = File::open(&amp;#34;hello.txt&amp;#34;).expect(&amp;#34;Failed to open hello.txt&amp;#34;); } 错误传播: ? # 上面的unwrap()显然比较粗糙。
我们看一下下面的例子：
use std::fs::File; use std::io::{self, Read}; fn read_username_from_file() -&amp;gt; Result&amp;lt;String, io::Error&amp;gt; { let username_file_result = File::open(&amp;#34;hello.</description></item></channel></rss>