[{"id":0,"href":"/cookbook/rust-project/cross-compile/","title":"交叉编译","section":"Rust项目工程","content":" 交叉编译 # 就是添加相应的target, 然后使用相应的工具链进行编译。\n添加target # 比如我在debian上，添加windows的target\nrustup target add x86_64-pc-windows-gnu 有哪些target可以添加，可以查看 https://doc.rust-lang.org/nightly/rustc/platform-support.html\n编译到target # cargo build --release --target=x86_64-pc-windows-gnu 报错 # error: linker x86_64-w64-mingw32-gcc not found\nsudo apt-get install gcc-mingw-w64 "},{"id":1,"href":"/cookbook/golang-syntax/basic/","title":"基础","section":"Golang语法速查","content":" 基础 # "},{"id":2,"href":"/cookbook/rust-syntax/basic/","title":"基础","section":"Rust语法速查","content":" 基础 # mut # 默认变量是不可变的(immutable)\nfn main() { let x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 6; // error[E0384]: cannot assign twice to immutable variable `x` println!(\u0026#34;The value of x is: {}\u0026#34;, x); } 加上mut\nfn main() { let mut x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 6; println!(\u0026#34;The value of x is: {}\u0026#34;, x); } const # const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; shadowing # fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\u0026#34;The value of x in the inner scope is: {}\u0026#34;, x); // 12 } println!(\u0026#34;The value of x is: {}\u0026#34;, x); // 6 } tuple # 用小括号包裹多个值, 可以是不同类型。通过解构赋值获取其中的值，或者通过索引访问。\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;The value of y is: {}\u0026#34;, y); println!(\u0026#34;The first element of tup is: {}\u0026#34;, tup.0); } array # 用方括号包裹多个值，必须是相同类型。通过索引访问。\nfn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; } fn # 函数使用fn关键字定义，可以有或无参数和返回值。参数和返回值必须声明类型。最后一行如果是表达式，会被返回。\nfn main() { let x = plus_one(5); println!(\u0026#34;The value of x is: {}\u0026#34;, x); } fn plus_one(x: i32) -\u0026gt; i32 { x + 1 // 等价于 return x + 1; } 注释 # // 我们在这里处理一些复杂事情，需要足够长的解释，使用 // 多行注释可做到这点。哇！我们希望这个注释将解释接下 // 来要实现的内容。 fn main() { // 单行可以写这里 let lucky_number = 7; // 单行也可以写这里 } "},{"id":3,"href":"/cookbook/rust-syntax/control-flow/","title":"控制流","section":"Rust语法速查","content":" 控制流 # if条件 # if .. else .. # fn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026#34;condition was true\u0026#34;); } else { println!(\u0026#34;condition was false\u0026#34;); } } else if # fn main() { let number = 6; if number % 4 == 0 { println!(\u0026#34;number is divisible by 4\u0026#34;); } else if number % 3 == 0 { println!(\u0026#34;number is divisible by 3\u0026#34;); } else if number % 2 == 0 { println!(\u0026#34;number is divisible by 2\u0026#34;); } else { println!(\u0026#34;number is not divisible by 4, 3, or 2\u0026#34;); } } if condition {1} else {2} # fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\u0026#34;The value of number is: {}\u0026#34;, number); } if let Some(x) = x {..} # if let Some(3) = some_u8_value { println!(\u0026#34;three\u0026#34;); } 等价于 match x {Some(x) =\u0026gt; ..}\nlet some_u8_value = Some(0u8); match some_u8_value { Some(3) =\u0026gt; println!(\u0026#34;three\u0026#34;), _ =\u0026gt; (), } 循环 # loop { break } # fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; // break可以带返回值，并赋值给result } }; println!(\u0026#34;The result is {}\u0026#34;, result); } 'label loop { break 'label } # fn main() { let mut count = 0; \u0026#39;counting_up: loop { println!(\u0026#34;count = {}\u0026#34;, count); let mut remaining = 10; loop { println!(\u0026#34;remaining = {}\u0026#34;, remaining); if remaining == 9 { break; } if count == 2 { break \u0026#39;counting_up; } remaining -= 1; } count += 1; } println!(\u0026#34;End count = {}\u0026#34;, count); } while # fn main() { let mut number = 3; while number != 0 { println!(\u0026#34;{}!\u0026#34;, number); number -= 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } for iter # fn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\u0026#34;the value is: {}\u0026#34;, element); } } for range # range只能小到大, 可以用.rev()逆序\nfn main() { for number in (1..4).rev() { println!(\u0026#34;{}!\u0026#34;, number); } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } match # match enum # enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; { println!(\u0026#34;Lucky penny!\u0026#34;); // 如果更多逻辑可以加{}，并最后返回表达式 1 } Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter(state) =\u0026gt; { // 绑定值可以捕获，变量名自定, 不捕获用_ println!(\u0026#34;State quarter from {:?}!\u0026#34;, state); 25 } } } match Option\u0026lt;T\u0026gt; # fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { None =\u0026gt; None, Some(i) =\u0026gt; Some(i + 1), } } let five = Some(5); let six = plus_one(five); let none = plus_one(None); match Result\u0026lt;T, E\u0026gt; # use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; { panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, error) }, }; } "},{"id":4,"href":"/cookbook/rust-syntax/shorten/","title":"简写","section":"Rust语法速查","content":" 简写 # unwrap # 对于Result\u0026lt;T, E\u0026gt;类型，我们需要频繁使用Match来获取其中的值，当我们在写主逻辑时可以先不考虑错误处理，此时使用unwrap()方法可以快速获取其中的值，如果有错误则会panic。\nuse std::fs::File; fn main() { let _greeting_file = File::open(\u0026#34;hello.txt\u0026#34;).unwrap(); } "}]